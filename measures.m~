
function evaluated_stat = measures(gt, seg, method, voxelwise)
% ------------------------------------------------------------------------
% evaluated_stat = evalseg(gt,seg,method)
% 
% Compute different segmentation statistics. 
%
%   gt = Binary 3D image containing the ground-truth data.
%   seg = binary 3D image containing the estimated segmentation mask
%   method = Evalutation method:
%       'dsc' : Dice Similarity Coefficient
%       'aov' : Area d'Overlap
%       'tpf' : True Positive Fraction
%       'tnf' : True Negative Fraction
%       'all' : Compute all the evaluation stats reported above
%
%   voxelwise = True positive / False positive / False Negative can be 
%                computed voxelwise or regiowise
%                'rfnf' : not detected lesion regions / total lesion
%                         regions (gt)
%                'rtpf' : true detected lesion regions / total lesion
%                         regions (gt)
%                'rfpf' : false detected lesion regions / total lesion
%                         regions (gt)
%
%
%  June 2015 Sergi Valverde / Mariano Cabezas
%  sergi.valverde@udg.edu
% ------------------------------------------------------------------------
  

% Function initialization
if nargin<2,
    error('Uhmm.. looks like the number of parameters is incorrect...');
elseif nargin==2,
    method='dsc';
    voxelwise = 1;
end

% -----------------------------------------------
% voxelwise evaluation (M.Cabezas implementation)
% -----------------------------------------------

ne=numel(gt);

% true positive fraction
tpf = sum(reshape(gt&seg,ne,1))/sum(reshape(gt,ne,1)); 
% true negative fraction
tnf = sum(reshape(~gt&~seg,ne,1))/sum(reshape(~gt,ne,1));    
% false positive fraction
fpf = sum(reshape(~gt&seg,ne,1))/ (sum(reshape(~gt,ne,1))); 
% false negative fraction
fnf = sum(reshape(gt&~seg,ne,1))/sum(reshape(gt,ne,1));      
% Area overlap
aov = sum(reshape(gt&seg,ne,1))/sum(reshape(gt|seg,ne,1));   
% Sensitivity
sens = sum(reshape(gt&seg,ne,1)) / (sum(reshape(gt&seg,ne,1))+sum(reshape(gt&~seg,ne,1))); 
% Specificity
spec = (sum(reshape(~gt&~seg,ne,1)) - back_voxels) / ((sum(reshape(~gt&~seg,ne,1)) - back_voxels) +sum(reshape(~gt&seg,ne,1))); 
% Precision
prec = sum(reshape(gt&seg,ne,1)) / (sum(reshape(gt&seg,ne,1))+sum(reshape(~gt&seg,ne,1))); 
% Recall
rec = sum(reshape(~gt&~seg,ne,1)) / (sum(reshape(~gt&~seg,ne,1))+sum(reshape(gt&~seg,ne,1))); 
% Dice coefficient
dsc = 2*(sum(reshape(seg&gt,ne,1))) / (sum(reshape(seg,ne,1))+sum(reshape(gt,ne,1))); 

% Tanimoto coefficient
%tn = (sum(reshape(gt&seg,ne,1))+sum(reshape(~(gt|seg),ne,1)))/(sum(reshape(gt|seg,ne,1))+sum(reshape(~(gt&seg),ne,1))); % Tanimoto
% Volume similarity
%vs = 1 - sum(sum(gt(:))-sum(seg(:)))/(sum(gt(:))+sum(seg(:)));       % Volume Similarity



if ~voxelwise
    %region-wise evaluation:
    % number of lesions in 3D
    seg_lesions = bwconncomp(seg,6);
    gt_lesions = bwconncomp(gt,6);
    
    num_seg_lesions = seg_lesions.NumObjects;
    num_gt_lesions = gt_lesions.NumObjects;
    % tp / fn / fp lesion regions.
    rtpf = sum(cellfun(@(x) sum(seg(x) & gt(x)) >0, gt_lesions.PixelIdxList)) / num_gt_lesions;
    rfnf = sum(cellfun(@(x) sum(seg(x) & gt(x)) == 0, gt_lesions.PixelIdxList)) / num_gt_lesions;
    rfpf = sum(cellfun(@(x) sum(seg(x) & gt(x)) == 0, seg_lesions.PixelIdxList)) / num_gt_lesions;
end
   
% Choose the method given the input

switch lower(method)
    case 'tpf'
        E = tpf;
    case 'tnf'
        E = tnf;
    case 'fpf'
        E = fpf;
    case 'fnf'
        E = fnf;    
    case 'aov'
        E = aov;
    case 'dsc'
        E = dsc;
    case 'graphic'
        E = im;
    case 'tn'
        E = tn;
    case 'vs'
        E = vs;
    case 'sens'
        E = sens;
    case 'spec'
        E =spec;
    case 'prec'
        E =prec;
    case 'rec'
        E =rec;
        
    case 'full'
        %E.im = im;
        E.dsc = dsc;
        E.aov = aov;
        E.tpf = tpf;
        E.tnf = tnf;
        E.fpf = fpf;
        E.aov = aov;
        %imshow(E.im);
        %title(['Numeric: ' num2str(E.dsc)]);
    otherwise
        E=[];

end
